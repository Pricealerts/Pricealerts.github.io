//const functions = require("firebase-functions");
const admin = require("firebase-admin");
const { onRequest } = require("firebase-functions/v2/https");
const logger = require("firebase-functions/logger");
const axios = require("axios");


admin.initializeApp();

// *** ุจูุงูุงุช ุงุนุชูุงุฏ Telegram Bot API (ูุง ุชูุณ ุชุญุฏูุซูุง) ***
const TELEGRAM_BOT_TOKEN = "8146635194:AAFGD_bkO7OSXHWdEf5ofe35Jm4DjslIhOE"; // ุงุญุตู ุนููู ูู @BotFather
/* let responseAppScrpt = {
  action : 'okResponse',
  dltRw : []
}; */

let dltRwApp = []
const APPS_SCRIPT_WEB_APP_URL =
  "https://script.google.com/macros/s/AKfycbz0hE-JXd26WjQtLOwp3SZI5_x5ZETBZjWPxFutRyZiPMDn01khIam6tVxBanNl-O2s/exec";

exports.proxyRequest = onRequest(
  { region: "europe-west1" },
   (req, res) => {
    const tabelAlert = req.method === "POST" ? req.body.datas : req.query.datas;
    res.send("cbn");

    if (!tabelAlert) {
      return res
        .status(400)
        .json({ error: "The 'url' parameter is required." });
    }
    try {
      //const response = await axios.get(tabelAlert);
      checkAndSendAlerts(tabelAlert)

 /*  const usedMemory = process.memoryUsage().heapUsed / 1024 / 1024;
  res.send(`ุฐุงูุฑุฉ ูุณุชุฎุฏูุฉ: ~${Math.round(usedMemory)}MB`); */

    } catch (error) {
      logger.error("Axios error:", error.message);
      return res.status(500).json({
        error: "Failed to fetch data",
        details: error.message,
      });
    }
  }
);

// ุชุนุฑูู ุงูููุตุงุช ุงููุฏุนููุฉ ููุงุฌูุงุช ุจุฑูุฌุฉ ุงูุนููุงุช ุงูุฎุงุตุฉ ุจูุง ููุฌุงูุจ ุงูุฎููู (Apps Script)
const EXCHANGES_CONFIG = {
    binance: {
        name: "Binance",
        tickerPriceUrl: 'https://api.binance.com/api/v3/ticker/price',
        candlestickUrl: 'https://api.binance.com/api/v3/klines', // ููุทุฉ ููุงูุฉ ุงูุดููุน
        usdtSuffix: 'USDT',
        // ูุชูุณูุฑ ุจูุงูุงุช ุงูุดูุนุฉ [timestamp, open, high, low, close, volume, ...]
        parseCandle: (c) => ({
            time: parseInt(c[0]),
            open: parseFloat(c[1]),
            high: parseFloat(c[2]),
            low: parseFloat(c[3]),
            close: parseFloat(c[4]),
            volume: parseFloat(c[5])
        }),
        intervalMap: { '1m': '1m', '5m': '5m', '15m': '15m', '1h': '1h' }
    },
    kucoin: {
        name: "KuCoin",
        tickerPriceUrl: 'https://api.kucoin.com/api/v1/market/orderbook/level1',
        candlestickUrl: 'https://api.kucoin.com/api/v1/market/candles',
        usdtSuffix: 'USDT',
        // ูุชูุณูุฑ ุจูุงูุงุช ุงูุดูุนุฉ [timestamp, open, close, high, low, volume, amount]
        parseCandle: (c) => ({
            time: parseInt(c[0]) * 1000, // KuCoin returns seconds
            open: parseFloat(c[1]),
            close: parseFloat(c[2]),
            high: parseFloat(c[3]),
            low: parseFloat(c[4]),
            volume: parseFloat(c[5])
        }),
        intervalMap: { '1m': '1min', '5m': '5min', '15m': '15min', '1h': '1hour' }
    },
    coincap: {
        name: "coincap",
        tickerPriceUrl: 'https://api.coincap.io/v2/public/tickers',
        candlestickUrl: 'https://api.coincap.io/v2/public/kline', // coincap v2 kline for spot
        usdtSuffix: 'USDT',
        // ูุชูุณูุฑ ุจูุงูุงุช ุงูุดูุนุฉ (open_time, open, high, low, close, volume, ...)
        parseCandle: (c) => ({
            time: parseInt(c.open_time) * 1000, // coincap returns seconds
            open: parseFloat(c.open),
            high: parseFloat(c.high),
            low: parseFloat(c.low),
            close: parseFloat(c.close),
            volume: parseFloat(c.volume)
        }),
        intervalMap: { '1m': '1', '5m': '5', '15m': '15', '1h': '60' }
    },
    coingecko: {
        name: "coingecko",
        tickerPriceUrl: 'https://api.coingecko.com/api/v3/coins/',
        candlestickUrl: 'https://api.coingecko.com/api/v3/coins/', // coingecko v2 kline for spot
        usdtSuffix: 'USD',
        // ูุชูุณูุฑ ุจูุงูุงุช ุงูุดูุนุฉ (open_time, open, high, low, close, volume, ...)
        parseCandle: (c) => ({
             time: c[0],
              open: c[1],
              high: c[2],
              low: c[3],
              close: c[4]
        }),
        intervalMap: { '1m': '1', '5m': '5', '15m': '15', '1h': '60' }
    },

    okx: {
        name: "OKX",
        tickerPriceUrl: 'https://www.okx.com/api/v5/market/tickers',
        candlestickUrl: 'https://www.okx.com/api/v5/market/candles',
        usdtSuffix: '-USDT',
        // ูุชูุณูุฑ ุจูุงูุงุช ุงูุดูุนุฉ [timestamp, open, high, low, close, volume, ...]
        parseCandle: (c) => ({
            time: parseInt(c[0]),
            open: parseFloat(c[1]),
            high: parseFloat(c[2]),
            low: parseFloat(c[3]),
            close: parseFloat(c[4]),
            volume: parseFloat(c[6]) // OKX has different volume fields
        }),
        intervalMap: { '1m': '1m', '5m': '5m', '15m': '15m', '1h': '1H' }
    }
};


async function checkAndSendAlerts(data) {

  const currentTriggerTime = new Date(); // ููุช ุชุดุบูู ุงูู Trigger ุงูุญุงูู

  // ูุชูุฑุฑ ุนูู ุงูุตููู ูู ุงูุฃุณูู ููุฃุนูู ูุณูููุฉ ุงูุญุฐู
  for (let i = data.length - 1; i >= 0; i--) { // ุงูุจุฏุก ูู ุขุฎุฑ ุตู ุจูุงูุงุช (ุจุงุณุชุซูุงุก ุงูุฑุคูุณ)
    let row = data[i];
    let exchangeId = row[1];
    let symbol = row[2];
    let targetPrice = parseFloat(row[3]);
    let alertCondition = row[4];
    let telegramChatId = row[5];
    let status = row[6]; // ุงูุนููุฏ G ูู ุงูุดูุช (Status)
    let requestTimeStr = row[7]; // ุงูุนููุฏ H ูู ุงูุดูุช (Request Time)
    // ุนููุฏ Last Checked ูู row[8]

    // ุงูุชูุจููุงุช ุงูุชู ุชุนูู ูู ุงูุฎูููุฉ ูู ููุท ุชูุจููุงุช Telegram ุงููุดุทุฉ
    if (status === "Active") {
      

      let requestTime = new Date(requestTimeStr);
      let timeDifferenceMs = currentTriggerTime.getTime() - requestTime.getTime();
      let timeDifferenceMinutes = Math.floor(timeDifferenceMs / (1000 * 60));

      let interval;
      let limit;

      if (timeDifferenceMinutes <= 5) {
          // ุฅุฐุง ูุงู ุงููุงุฑู 0-5 ุฏูุงุฆูุ ุงุณุชุฎุฏู ุดููุน 1 ุฏูููุฉ
          interval = '1m';
          limit = Math.max(1, timeDifferenceMinutes); // ุนูู ุงูุฃูู ุดูุนุฉ ูุงุญุฏุฉ
      } else {
          // ุฅุฐุง ูุงู ุงููุงุฑู ุฃูุจุฑ ูู 5 ุฏูุงุฆูุ ุงุณุชุฎุฏู ุดูุนุฉ 5 ุฏูุงุฆู ูุงุญุฏุฉ
          interval = '5m';
          limit = 1;
      }
      
      let candles = await fetchCandlestickData(exchangeId, symbol, interval, limit);
      let triggeredByHistoricalPrice = false;
      let actualTriggerPrice = null; // ูุชุณุฌูู ุงูุณุนุฑ ุงูุฐู ุชุณุจุจ ูู ุงูุชูุจูู

      if (candles && candles.length > 0) {
          // ุฅุฐุง ูุงูุช ุงูุดููุน 1mุ ูุฌุจ ุฃู ููุญุต ูู ุดูุนุฉ
          for (const candle of candles) {
            if (alertCondition === 'less_than_or_equal') {
                if (candle.low <= targetPrice) {
                    triggeredByHistoricalPrice = true;
                    actualTriggerPrice = candle.low;
                    break; // ูุฌุฏูุง ุงูุชุญููุ ูุง ุฏุงุนู ูููุงุตูุฉ ุงููุญุต
                }
            } else if (alertCondition === 'greater_than_or_equal') {
                if (candle.high >= targetPrice) {
                    triggeredByHistoricalPrice = true;
                    actualTriggerPrice = candle.high;
                    break; // ูุฌุฏูุง ุงูุชุญููุ ูุง ุฏุงุนู ูููุงุตูุฉ ุงููุญุต
                }
            }
          }
          
      } else {
           console.warn(`ูู ูุชู ุงูุญุตูู ุนูู ุจูุงูุงุช ุดูุนุฉ (${interval}, limit: ${limit}) ูู ${symbol} ุนูู ${EXCHANGES_CONFIG[exchangeId].name}. ูุฏ ุชููู ุญุฏูุฏ API ุฃู ุนุฏู ุชููุฑ ุงูุจูุงูุงุช.`);
      }

      if (triggeredByHistoricalPrice) {

          let message = `๐ ุชูุจูู ุณุนุฑ ${EXCHANGES_CONFIG[exchangeId].name}!\nุนููุฉ <b>${symbol}</b> ุจูุบุช <b>${actualTriggerPrice} USDT</b>. (ุงูุดุฑุท: ุงูุณุนุฑ ${alertCondition === 'less_than_or_equal' ? 'ุฃูู ูู ุฃู ูุณุงูู' : 'ุฃุนูู ูู ุฃู ูุณุงูู'} ${targetPrice} USDT)`;
          let sendResult =await sendTelegramMessage(telegramChatId, message);

          if (sendResult.success) {
              let iPls = i+2
              dltRwApp.push(iPls)
              // ุจูุง ุฃููุง ุญุฐููุง ุงูุตูุ ูุฌุจ ุฃู ูููู ุงูููุฑุณ ูุชุฌูุจ ุชุฎุทู ุตููู
              data.splice(i, 1); // ุฅุฒุงูุฉ ุงูุตู ุงููุญุฐูู ูู ูุตูููุฉ ุงูุจูุงูุงุช ุงููุญููุฉ ุฃูุถูุง
          } else {
              // ุฅุฐุง ูุดู ุงูุฅุฑุณุงูุ ูุง ุชุญุฐู ุงูุชูุจูู ุญุชู ูููู ุงููุญุงููุฉ ูุฑุฉ ุฃุฎุฑู ูุงุญููุง
              console.error(`ูุดู ุฅุฑุณุงู ุฅุดุนุงุฑ ุชูููุฌุฑุงู ูู ${symbol}:`, sendResult.error);
              // ูููููุง ุชุนููู ุญุงูุฉ ุงูุชูุจูู ุฅูู "Failed" ูู ุงูุดูุช ุฅุฐุง ุฃุฑุฏูุง ุชุชุจุน ุงูุฃุฎุทุงุก
              // sheet.getRange(i + 1, 7).setValue("Failed");
          }
      }
    }
  }
   let retour = await callFirebaseWithPost()
}

/**
 * ุฏุงูุฉ ูุฌูุจ ุจูุงูุงุช ุงูุดููุน (OHLCV) ูู ุงูููุตุฉ ุงููุญุฏุฏุฉ ููุชุฑุฉ ูุนููุฉ.
 * @param {string} exchangeId - ูุนุฑู ุงูููุตุฉ.
 * @param {string} symbol - ุฑูุฒ ุงูุนููุฉ (ูุซุงู: BTCUSDT).
 * @param {string} interval - ุงููุงุตู ุงูุฒููู ููุดูุนุฉ (ูุซุงู: '1m', '5m', '15m').
 * @param {number} limit - ุนุฏุฏ ุงูุดููุน ุงููุฑุงุฏ ุฌูุจูุง.
 * @returns {Array<Object> | null} ูุตูููุฉ ูู ูุงุฆูุงุช ุงูุดููุน ุฃู null ูู ุญุงูุฉ ุงููุดู.
 */
async function fetchCandlestickData(exchangeId, symbol, interval, limit) {
    const exchange = EXCHANGES_CONFIG[exchangeId];
    if (!exchange || !exchange.candlestickUrl || !exchange.parseCandle || !exchange.intervalMap[interval]) {
        console.error(`ููุตุฉ ${exchangeId} ูุง ุชุฏุนู ุฌูุจ ุจูุงูุงุช ุงูุดููุน ุฃู URL/parseCandle/intervalMap ุบูุฑ ูุนุฑู ูู ${interval}.`);
        return null;
    }

    let apiUrl = '';
    const now = new Date();
    const endTimeMs = now.getTime();
    
    // ูุญุณุงุจ ููุช ุงูุจุฏุก ูุทูุจ ุงูุดูุนุฉ ุงูุฃุฎูุฑุฉ
    const intervalMs = parseIntervalToMilliseconds(interval);
    // ูุญุฏุฏ ููุช ุงูุจุฏุก ูุถูุงู ุงูุญุตูู ุนูู ุงูุดููุน ุงููุทููุจุฉ ุจุงูุถุจุท
    // ูุซูุงู: ูู ุทูุจูุง 3 ุดููุน 1mุ ูุฑูุฏ 3 ุฏูุงุฆู ูู ุงูุจูุงูุงุช.
    const startTimeMs = endTimeMs - (intervalMs * limit); 

    try {
        let response, datas;
        let mappedInterval = exchange.intervalMap[interval];

        switch (exchangeId) {
            case 'binance':
                apiUrl = `${exchange.candlestickUrl}?symbol=${symbol}&interval=${mappedInterval}&limit=${limit}`;
                break;
            case 'kucoin':
                // KuCoin uses 'startAt' and 'endAt' in seconds
                apiUrl = `${exchange.candlestickUrl}?symbol=${symbol}&type=${mappedInterval}&startAt=${Math.floor(startTimeMs / 1000)}&endAt=${Math.floor(endTimeMs / 1000)}`;
                break;
            case 'coincap':
                // coincap v2 kline uses 'from' in seconds
                apiUrl = `${exchange.candlestickUrl}?symbol=${symbol}&interval=${mappedInterval}&limit=${limit}&from=${Math.floor(startTimeMs / 1000)}`;
                break;
            case 'coingecko':
                // coingecko v2 kline uses 'from' in seconds
                apiUrl = `${exchange.candlestickUrl}${symbol}/ohlc?vs_currency=usd&days=1`;
            break;
            case 'okx':
                // OKX uses 'before' and 'after' in milliseconds
                apiUrl = `${exchange.candlestickUrl}?instId=${symbol}&bar=${mappedInterval}`;
                break;
            default:
                console.warn(`ุฌูุจ ุงูุดููุน ุบูุฑ ูุฏุนูู ููููุตุฉ: ${exchangeId}`);
                return null;
        }
    
       
        //console.log(`apiUrl   is :${apiUrl}`)
        datas = (await axios.get(apiUrl)).data;

        //console.log(`datas ed data  is :`)
        //console.log(datas);
        
        let candles = [];
        if (exchangeId === 'binance') {
          candles = datas.map(exchange.parseCandle);
        }else if (exchangeId === 'kucoin') {
             if (datas.code === '200000' ) { 
                candles = datas.data.map(exchange.parseCandle);
            } else {
                console.error(`ุฎุทุฃ ูู ${exchange.name} API (ุดููุน):`, datas.msg || JSON.stringify(datas));
            }
        }else if (  exchangeId === 'okx') { 
            if (datas.code === '200000' || datas.code === '0') {
                candles = datas.data.map(exchange.parseCandle);
            } else {
                console.error(`ุฎุทุฃ ูู ${exchange.name} API (ุดููุน):`, datas.msg || JSON.stringify(datas));
            }
        } else if (exchangeId === 'coincap') {
            if (datas.ret_code === 0 && datas.result) {
                candles = datas.result.map(exchange.parseCandle);
            } else {
                console.error(`ุฎุทุฃ ูู ${exchange.name} API (ุดููุน):`, datas.ret_msg || JSON.stringify(datas));
            }
        }else {
            if (Array.isArray(datas) && datas.length) {
                candles = datas.map(exchange.parseCandle);
            } else {
                console.error(`ุฎุทุฃ ูู ${exchange.name} API (ุดููุน):`, JSON.stringify(datas));
            }
        }
        
        // ูุฏ ุชุฑุฌุน ุงูููุตุงุช ุดููุนูุง ุฃูุซุฑ ููุง ุทูุจูุงูุ ุฃู ุจุชุฑุชูุจ ูุนููุณ.
        // ููุชุฃูุฏ ูู ุงูุญุตูู ุนูู ุฃุญุฏุซ ุงูุดููุน ูุญุชู ุงูุนุฏุฏ ุงููุญุฏุฏ.
        // ุบุงูุจูุง ูุง ูุชู ุฅุฑุฌุงุนูุง ุจุชุฑุชูุจ ุฒููู ุชุตุงุนุฏู (ุงูุฃูุฏู ุฃููุงู).
        // ุฅุฐุง ูุงู ูุฐููุ ูุฃุฎุฐ ุขุฎุฑ 'limit' ูู ุงูุดููุน.
        return candles.slice(-limit); 

    } catch (error) {
        console.error(`ุฎุทุฃ ูู ุฌูุจ ุจูุงูุงุช ุงูุดููุน ูู ${symbol} ูู ${exchange.name}:`, error);
        return null;
    }
}

async function callFirebaseWithPost() {
    //console.log(responseAppScrpt);
    
 
  if (dltRwApp.length == 0) {return 'walo'}
  try {
    //const response = await axios.post(APPS_SCRIPT_WEB_APP_URL, options);
    await axios.post(APPS_SCRIPT_WEB_APP_URL, {
        action: 'okResponse',
        dltRw: dltRwApp
        },{
        headers: { 'Content-Type': 'application/json' }
        });
        
    } catch (error) {
        console.error("error  respons", error.response ? error.response.data : error.message);
        return { success: false, error: error.response ? error.response.data : error.message };
    }

}
/**
 * ุฏุงูุฉ ูุณุงุนุฏุฉ ูุชุญููู ุงููุงุตู ุงูุฒููู ุงููุตู ุฅูู ูููู ุซุงููุฉ.
 */
function parseIntervalToMilliseconds(interval) {
    const value = parseInt(interval.slice(0, -1));
    const unit = interval.slice(-1);
    switch (unit) {
        case 'm': return value * 60 * 1000; // minutes
        case 'h': return value * 60 * 60 * 1000; // hours
        case 'd': return value * 24 * 60 * 60 * 1000; // days
        case 'w': return value * 7 * 24 * 60 * 60 * 1000; // weeks
        default: return 0; // Should not happen with defined intervals
    }
}



/**
 * ุฏุงูุฉ ูุฅุฑุณุงู ุฑุณุงูุฉ Telegram.
 */
async function sendTelegramMessage(chatId, messageText) {
  if (!TELEGRAM_BOT_TOKEN || TELEGRAM_BOT_TOKEN === "YOUR_TELEGRAM_BOT_TOKEN") {
    console.error("TELEGRAM_BOT_TOKEN ุบูุฑ ูุนุฑูู ุฃู ุบูุฑ ุตุงูุญ ูู Apps Script.");
    return { success: false, error: "ุชููู ุจูุช ุชูููุฌุฑุงู ุบูุฑ ููุฌูุฏ." };
  }
  const TELEGRAM_API_URL = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;

  let payload = {
    chat_id: chatId,
    text: messageText,
    parse_mode: 'HTML'
  };

  try {
    const response = await axios.post(TELEGRAM_API_URL, payload);
        return { success: true, response: response.data };
    } catch (error) {
        console.error("ุฎุทุฃ ูู ุฅุฑุณุงู ุฑุณุงูุฉ ุชูููุฌุฑุงู:", error.response ? error.response.data : error.message);
        return { success: false, error: error.response ? error.response.data : error.message };
    }
}





